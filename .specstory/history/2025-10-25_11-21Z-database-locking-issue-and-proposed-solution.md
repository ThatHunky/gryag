<!-- Generated by SpecStory -->

<!-- vscode Session 366c2865-35eb-4e59-adc1-130d41880611 (2025-10-25 11:21Z) -->

# Database locking issue and proposed solution (2025-10-25 11:21Z)

_**User (2025-10-25 11:28Z)**_

```
bot-1  | 2025-10-25 11:20:47 - INFO - aiogram.event - Update id=998007865 is handled. Duration 5307 ms by bot id=8082154386
bot-1  | 2025-10-25 11:20:47 - ERROR - app.handlers.chat - Failed to persist unaddressed message 70303: database is locked
bot-1  | Traceback (most recent call last):
bot-1  |   File "/app/app/handlers/chat.py", line 375, in _remember_context_message
bot-1  |     await store.add_turn(
bot-1  |   File "/app/app/services/context_store.py", line 268, in add_turn
bot-1  |     await db.execute(
bot-1  |   File "/usr/local/lib/python3.12/site-packages/aiosqlite/core.py", line 183, in execute
bot-1  |     cursor = await self._execute(self._conn.execute, sql, parameters)
bot-1  |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
bot-1  |   File "/usr/local/lib/python3.12/site-packages/aiosqlite/core.py", line 122, in _execute
bot-1  |     return await future
bot-1  |            ^^^^^^^^^^^^
bot-1  |   File "/usr/local/lib/python3.12/site-packages/aiosqlite/core.py", line 105, in run
bot-1  |     result = function()
bot-1  |              ^^^^^^^^^^
bot-1  | sqlite3.OperationalError: database is locked
bot-1  | 2025-10-25 11:20:47 - INFO - aiogram.event - Update id=998007866 is handled. Duration 5398 ms by bot id=8082154386
bot-1  | 2025-10-25 11:20:47 - ERROR - app.handlers.chat - Failed to persist unaddressed message 70304: database is locked
bot-1  | Traceback (most recent call last):
bot-1  |   File "/app/app/handlers/chat.py", line 375, in _remember_context_message
bot-1  |     await store.add_turn(
bot-1  |   File "/app/app/services/context_store.py", line 268, in add_turn
bot-1  |     await db.execute(
bot-1  |   File "/usr/local/lib/python3.12/site-packages/aiosqlite/core.py", line 183, in execute
bot-1  |     cursor = await self._execute(self._conn.execute, sql, parameters)
bot-1  |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
bot-1  |   File "/usr/local/lib/python3.12/site-packages/aiosqlite/core.py", line 122, in _execute
bot-1  |     return await future
bot-1  |            ^^^^^^^^^^^^
bot-1  |   File "/usr/local/lib/python3.12/site-packages/aiosqlite/core.py", line 105, in run
bot-1  |     result = function()
bot-1  |              ^^^^^^^^^^
bot-1  | sqlite3.OperationalError: database is locked
bot-1  | 2025-10-25 11:20:47 - INFO - aiogram.event - Update id=998007867 is handled. Duration 5473 ms by bot id=8082154386
bot-1  | 2025-10-25 11:20:58 - INFO - app.handlers.chat - Processing message
```

Why does the database get locked? Can you fix?

---

_**Assistant (copilot/gpt-5-codex)**_

**Inspecting context_store.py for SQLite****Investigating SQLite concurrency issues**

I'll look into how add_turn opens a new SQLite connection each time and consider setting PRAGMA options like journal_mode=WAL and busy_timeout to reduce locking. I also want to check if multiple services or processes might access the DB concurrently and explore other DB operations in the codebase for clues.**Analyzing SQLite concurrency and locking issues**

I'm examining why multiple concurrent writes to the SQLite DB cause `database is locked` errors, considering how `aiosqlite` connections and transactions behave. I want to improve concurrency by configuring WAL mode, adjusting busy timeouts, and ensuring consistent connection setup with increased timeout values, while also checking for other processes that might hold locks. I'll review current connection usages to spot possible conflicts or long transactions.**Correcting parameter name****Analyzing SQLite concurrency issues and solutions**

I'm exploring why the database locking happens during writes, focusing on the ContextStore's use of aiosqlite. It seems multiple concurrent writes with default 5-second timeouts cause conflicts. I’m considering increasing the busy timeout to 30 seconds, enabling WAL mode for better concurrency, and wrapping write operations in retry loops with exponential backoff. I plan to centralize connection setup in a `_connect` method that sets these PRAGMAs and updates all ContextStore usages to adopt it. This should help reduce locks while maintaining reasonable concurrency without heavy contention.**Designing retry logic and connection handling improvements**

I’m outlining an approach to add retry loops with exponential backoff around writes like `add_turn` to handle database locks gracefully, while increasing the SQLite timeout to 30 seconds and setting busy timeout PRAGMA on each connection. I plan to add a central `_connect` helper method and update all `aiosqlite.connect` calls in `ContextStore` to use consistent timeout settings. Also, I want to add logging for retries and refine connection initialization to set WAL mode once during startup, minimizing overhead while improving reliability.**Implementing timeout, retries, and PRAGMA settings**

I’m planning concrete code changes to add connection timeout and retries: setting 30-second timeout and busy timeout PRAGMA on DB initialization and all connection points, then wrapping `add_turn` in a retry loop with exponential backoff. Other methods will get updated connection timeout parameters for consistency. This should improve resilience against SQLite locking issues without drastic structural changes.
```

```
**Adjusting import order and init connection**
```

```
**Adding explicit type annotations to class attributes**

I’m analyzing lint errors likely caused by missing type hints for new attributes added to the class, especially `_connect_timeout`. To fix this, I'll add type annotations both at the class level and in `__init__`. Additionally, I’m considering improving safety by handling potential `None` on database row fetches to prevent runtime issues even if that wasn’t a new error. This should help silence type checker complaints and make the code more robust.
```

```
**Checking indentation issues in __init__ method****Correcting indentation and adding class-level attributes**
```

```
**Fixing lint error with None handling**
```

```
**Implementing add_turn with timeout**
```

```
**Ensuring consistent aiosqlite connection timeouts****Updating aiosqlite connection calls**
```

```
**Confirming all replacements****Evaluating SQLite timeout settings and testing strategy**

I'm reviewing how `aiosqlite.connect` uses the `timeout` parameter and `PRAGMA busy_timeout` to avoid database lock errors, verifying that redundant PRAGMA calls aren't necessary but harmless. I'm considering whether to extend this to other modules but will focus on `ContextStore` for now. Since we modified critical DB code, running targeted tests like `pytest tests/unit/test_context_store.py` seems wise, so I'll check if relevant test files exist before proceeding.**Listing unit tests****Preparing to run targeted tests**

I want to run tests relevant to our database changes, especially in `test_retention.py`, but first I need to call `configure_python_environment` with the workspace root to set up the Python environment properly before executing any Python commands or tests. This setup ensures consistency and follows developer instructions.**Preparing to run targeted tests****Preparing final response message**Simultaneous writes were timing out after SQLite’s default 5 s busy window, so when back-to-back updates tried to persist context turns the second insert hit “database is locked.” Enabling WAL, raising the busy timeout, and retrying the insert with backoff keeps the writer waiting instead of bailing.

**Changes**
- `context_store.py` – enable WAL and a 30 s busy timeout during init, and reuse that timeout on every connection so readers/writers wait longer before giving up.
- `context_store.py` – wrap `add_turn` inserts in an exponential backoff retry loop with diagnostic logging when we encounter a locked database.
- `context_store.py` – harden `count_requests_last_hour` against a `fetchone()` returning `None` to satisfy stricter type checks.

- Tests: `/home/thathunky/gryag/.venv/bin/pytest tests/unit/test_retention.py`

Next step: 1. Rebuild/restart the bot container and watch the log to confirm the “database is locked” errors stop surfacing.

---

